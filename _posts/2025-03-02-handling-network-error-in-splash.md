---
title: 네트워크 에러에도 끊김 없는 스플래시 화면 설계하기
date: 2025-03-02 00:48:00 +/-TTTT
categories: [Frontend, React Native]
tags: [react native, splash screen, network error, error handling, retry mechanism, error boundary, tanstack query, ux improvement]
sitemap:
  changefreq: daily
  priority: 0.5
---

> 목차
> 1. 개요
> 2. 문제 인식
> 3. 문제 접근
{: .prompt-tip }

## 1. 개요

> **스플래시(Splash)**
>
> 모바일 앱 실행 시 가장 처음 만나게 되는 화면으로, 보통 1초에서 3초정도 이어집니다. 대부분의 앱은 일반적으로 스플래시 UI를 가지고 있습니다. - [1초의 디테일, 스플래시 시각보정.](https://brunch.co.kr/@shaun/60)
{: .prompt-info }

현재 서비스는 앱을 시작하면 스플래시가 시작되고, 스플래시가 시작되는 동안 인증 정보와 사용자 정보를 받아오도록 플로우가 구성되어 있습니다. 이러한 플로우에는 한 가지 큰 문제점이 있습니다. 바로, 네트워크가 원활하지 않은 환경에서 앱을 시작하는 경우 로그아웃 된다는 것입니다.

**이게 왜 문제인가?** 라고 생각할 수 있는데, 네트워크 / 서버 측 에러(`5xx`)는 클라이언트 측에서 발생하는 문제가 아닌, 외부 환경적인 요소 영향을 받는 에러이기 때문에 앱 내 사용자에게는 영향을 주지 않아야 합니다.

즉, 이미 로그인 한 사용자는 잘못된 접근이 아닌 이상은 로그아웃 되지 않아야 한다는 말이죠!

이 글에서는 이러한 문제를 이러한 문제를 인식하는 과정부터, 다양한 해결 방법을 고려하고, 최종적으로 적절한 대안을 선택하여 문제를 해결한 경험을 공유하려 합니다.

## 2. 문제 인식

![App flow](assets/img/writing/15/app_flow.png){: width="720" }
_기존 플로우_

기존에는 앱 시작시 스플래시가 진행되는 동안 현재 앱 버전을 체크하고, 사용자 인증 정보 및 유저 정보를 받아오는 플로우로 구성되어 있었습니다.

언뜻 보기에는 문제가 없어 보이지만, 현재 위 플로우를 자세히 살펴보면, 네트워크 환경을 고려하지 않고 있기 때문에 네트워크가 원활하지 않거나 서버 에러가 발생하는 경우 토큰 재발급 요청에 실패하게 되어 <span style="color: #FF6262;">이미 로그인 한 사용자더라도 강제로 로그아웃처리 되는 문제</span>가 있습니다.

이러한 문제는 사용자가 다시 로그인을 시도하게 만듦으로써 사용자 경험을 크게 저하시키는 원인이 될 수 있습니다. 그렇기 때문에 이미 로그인한 사용자라면 로그인 상태를 최대한 유지할 수 있도록 플로우를 개선해야만 합니다.

## 3. 문제 접근

우선 이러한 문제점을 해결하기 위해서는 저는 "네트워크가/서버 에러가 발생한 경우에는 사용자 정보(`refreshToken`)를 잃지 않도록 하자"에 집중하여 접근하였습니다.

고려해본 방법은 크게 3가지입니다.

1. Api 요청이 시작되기 전 네트워크 연결을 확인하기
2. Queue를 활용한 Retry 처리
3. Retry and ErrorBoundary

각각의 접근 방법에 차근차근 알아보겠습니다.

### 3-1. Api 요청이 시작되기 전 네트워크 연결을 확인하기

우선 첫 번째로 생각해본 대안으로, 기존 플로우에서 현재 사용자 기기의 **"네트워크 상태를 체크하는 분기문을 최초 앱 시작 시 추가"**하는 것이였습니다.

![App flow 대안 1](assets/img/writing/15/app_flow_alternative1.png){: width="720" }
_첫 번째 대안_

앱을 실행하는 시점에 네트워크 상태를 확인하고, 스플래시가 종료되는 시점에 네트워크의 상태가 원활하지 않다면 `ConnectionError`를 렌더링하는 방법입니다. 이 방법은 네트워크 연결에 문제가 있음을 사용자에게 알려줄 수 있으며, `Refresh Api Call`이 진행되기 전 네트워크가 연결되어 있음을 보장할 수 있습니다.

하지만, 이러한 플로우에는 초기 네트워크 상황을 점검한 후(`Refresh Api Call` 요청 이후)의 상황에 대한 대안은 없기 때문에 `User Api Call`에서 에러가 발생하면 여전히 로그아웃 된다는 문제가 있습니다.

### 3-2. Queue를 활용한 Retry 처리

해당 방법은 이전 대안 1을 보완한 방법으로, 사용자가 원치 않은 에러 발생 UI(`ConnectionError`)를 보지 않도록하는 방법입니다.

두 번째 대안의 핵심은 **"Network/Server 에러가 발생한 경우, Queue에 해당 에러를 저장하고 네트워크가 연결되었을 때 에러가 발생한 Api들을 처리하는 방식"**으로, 사용자가 Network/Server 에러가 발생하면 Queue에 에러를 저장합니다. 그 후 사용자의 정보를 확인하는데, 사용자의 정보가 LocalStorage에 저장되어 있다면 이전에 로그인한 사용자이기 때문에 홈 페이지로 이동합니다.

![App flow 대안 2](assets/img/writing/15/app_flow_alternative2.png){: width="720" }
_두 번째 대안_

이 방식의 장점은 클라이언트와 서버 에러(4xx, 5xx) 처리를 분리하여, 기존 로그인 상태를 유지하면서도 네트워크 불안정성을 보완할 수 있다는 점입니다.

하지만 이를 구현하기 위해서는 너무나 많은 케이스를 고려해야 합니다.

1. LocalStorage에 저장된 유저 정보를 활용하는 방식은 보안 취약점을 초래할 수 있습니다.
2. 홈 페이지로 이동하는 조건이 두 가지가 존재하기 때문에 플로우의 복잡성이 증가합니다.
3. 인터셉터에서 네트워크 / `5xx` 에러 발생 시 Queue에 저장하는 로직을 구현해야 하며, 네트워크가 복구되었을 때 해당 요청을 다시 처리하는 로직이 필요합니다.
4. 홈 페이지로 이동한 이후, 서비스의 데이터를 요청하는 api 실패에 대한 사후 처리가 추가적으로 필요합니다.

네트워크/서버 에러가 발생한 경우 사용자 정보를 잃지 않을 수 있는 좋은 방법이지만, 해당 방법의 복잡도와 보안 문제를 고려해야할 뿐만 아니라 인증 플로우 이후 발생하는 추가적으로 에러에 대한 대응도 필요하기에 적합하지 않다고 생각하였습니다.

### 3-3. Retry and ErrorBoundary

마지막 대안으로, 기존 1번 대안의 문제점을 해결하면서 2번 대안의 복잡성을 낮추는 방식을 고려하였습니다. 플로우는 다음과 같습니다.

![App flow 대안 3](assets/img/writing/15/app_flow_alternative3.png){: width="720" }
_세 번째 대안_

기존 플로우를 최대한 유지하되 `5xx` 에러에 대해서는 `retry`를 1초의 딜레이를 유지하며 진행합니다. 그리고, 에러가 발생한다면 Splash가 종료된 이후 ErrorBoundary를 통해 에러가 발생한 Api에 대한 retry UI를 사용자에게 제공합니다.

해당 방식은 기존에 언급되었던 문제점을 해결하면서도, 인증 플로우의 복잡도를 최소화할 수 있다는 장점이 있습니다. 또한 ErrorBoundary를 적극 활용하여, 에러가 발생한 Api에 대한 retry를 진행함으로써 유연한 대응도 가능합니다.

물론 장점만 있는 것은 아닙니다. 해당 방법의 경우 재시도 횟수를 고려해야만 하며, 네트워크 에러와 서버 에러에 대한 대해 다르게 처리를 해줘야만 합니다.

### 🚀 3-4. 최종 결론

최종적으로 대안 1, 2, 3을 비교하였을 때 1번 대안은 기존의 문제는 제외하였습니다.

1번 대안(네트워크 상태 체크)은 앱 시작 시 네트워크 연결 여부를 확인하고, 문제가 있으면 `ConnectionError` 화면을 띄우는 방식이었습니다. 하지만, 네트워크 연결 여부는 **변화할 수 있기 때문에 앱 실행 시점만 확인하는 것에는 한계**가 있다고 판단했고, 네트워크 연결이 있다고 하더라도, API 요청이 실패할 가능성은 존재하기 때문에 1번 대안은 근본적인 해결책이 될 수 없다고 판단하여 제외하였습니다.

| 비교 요소                  | 2️⃣ Queue 방식 | 3️⃣ Retry & ErrorBoundary |
|---------------------------|---------------|---------------------------|
| **네트워크 불안정성 대응** | ✅ 네트워크 복구 후 자동 요청 및 재처리 | ✅ 자동 재시도(`Retry`) 및 UI에서 안내 가능 |
| **사용자 경험 (UX)**       | ✅ 투명한 복구 가능 | ✅ 자동 복구 + UI 안내 |
| **구현 난이도**           | ❌ 너무 복잡함 | ✅ 상대적으로 단순 |
| **유지보수 난이도**       | ❌ Queue 로직 관리 필요 | ✅ 재시도 정책만 설정하면 됨 |

## 4. 안정적인 플로우를 위한 테스트 전략

추후 작성 예정입니다.

## 5. Retry & ErrorBoundary 적용하기